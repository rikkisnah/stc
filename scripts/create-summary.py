#!/usr/bin/env python3
# Code was generated via OCI AI and was reviewed by a human SDE
# Tag: #ai-assisted
"""Create a category-level summary CSV from tickets-categorized output.

Usage:
    python3 scripts/create-summary.py --tickets scripts/analysis/tickets-categorized.csv
    python3 scripts/create-summary.py --tickets scripts/analysis/tickets-categorized.csv --output scripts/analysis/tickets-summary.csv
"""

import argparse
import csv
import sys
from collections import defaultdict
from pathlib import Path

DEFAULT_OUTPUT_NAME = "tickets-summary.csv"


def parse_args() -> argparse.Namespace:
    """Parse CLI arguments."""
    parser = argparse.ArgumentParser(
        description="Summarize categorized tickets by Category into a reporting CSV.",
    )
    parser.add_argument(
        "--tickets",
        type=Path,
        required=True,
        help="Path to tickets-categorized.csv generated by rule_engine_categorize.py",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=None,
        help="Output CSV path (defaults to <tickets parent>/tickets-summary.csv)",
    )
    return parser.parse_args()


def load_ticket_rows(tickets_csv: Path) -> list[dict[str, str]]:
    """Load categorized tickets as a list of rows."""
    with tickets_csv.open("r", newline="", encoding="utf-8") as infile:
        reader = csv.DictReader(infile)
        required_columns = {"Ticket", "Category"}
        if not reader.fieldnames or not required_columns.issubset(set(reader.fieldnames)):
            missing = sorted(required_columns - set(reader.fieldnames or []))
            raise ValueError(
                "Input CSV must include Ticket and Category columns. "
                f"Missing: {', '.join(missing)}"
            )
        return list(reader)


def build_jql_query(ticket_keys: list[str]) -> str:
    """Build a JQL query for a set of ticket keys."""
    if not ticket_keys:
        return ""
    joined = ", ".join(ticket_keys)
    return f"issuekey in ({joined})"


def summarize_by_category(rows: list[dict[str, str]]) -> list[dict[str, str]]:
    """Aggregate rows into summary records by Category."""
    total = len(rows)
    grouped: dict[str, list[str]] = defaultdict(list)

    for row in rows:
        category = (row.get("Category") or "unknown").strip() or "unknown"
        ticket_key = (row.get("Ticket") or "").strip()
        if ticket_key:
            grouped[category].append(ticket_key)

    summary_rows = []
    for category in sorted(grouped):
        ticket_keys = sorted(set(grouped[category]))
        count = len(ticket_keys)
        percentage = (count / total * 100) if total else 0
        summary_rows.append(
            {
                "Tickets Category": category,
                "Percentage of Total Tickets": f"{percentage:.2f}%",
                "Count of Tickets": str(count),
                "JQL Query": build_jql_query(ticket_keys),
            }
        )

    return summary_rows


def write_summary_csv(summary_rows: list[dict[str, str]], output_csv: Path) -> None:
    """Write summary records to output CSV."""
    output_csv.parent.mkdir(parents=True, exist_ok=True)
    fieldnames = [
        "Tickets Category",
        "Percentage of Total Tickets",
        "Count of Tickets",
        "JQL Query",
    ]
    with output_csv.open("w", newline="", encoding="utf-8") as outfile:
        writer = csv.DictWriter(outfile, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(summary_rows)


def main() -> None:
    """CLI entrypoint."""
    args = parse_args()

    if not args.tickets.is_file():
        sys.exit(f"Tickets CSV not found: {args.tickets}")

    output_csv = args.output if args.output else args.tickets.parent / DEFAULT_OUTPUT_NAME

    try:
        rows = load_ticket_rows(args.tickets)
    except ValueError as exc:
        sys.exit(str(exc))

    summary_rows = summarize_by_category(rows)
    write_summary_csv(summary_rows, output_csv)

    print(f"Input rows : {len(rows)}")
    print(f"Output CSV : {output_csv}")
    print(f"Categories : {len(summary_rows)}")


if __name__ == "__main__":
    main()
